\documentclass[11pt,a4paper]{article}

\usepackage{geometry}
 \geometry{
 a4paper,
 total={150mm,237mm},
 left=30mm,
 top=30mm,
 }

% cf. http://tex.stackexchange.com/questions/50182/subtitle-with-the-maketitle-page
\usepackage{titling}
\newcommand{\subtitle}[1]{%
  \posttitle{%
    \par\end{center}
    \begin{center}\large\textbf{#1}\end{center}
    \vskip0.5em}%
}

\usepackage{color}
\usepackage{graphicx}
\usepackage{subcaption}

% cf. https://tex.stackexchange.com/questions/58713
\usepackage{enumitem}

\usepackage[utf8]{inputenc}
\usepackage[lf]{venturis} %% lf option gives lining figures as default; 
\usepackage[T1]{fontenc}
\usepackage{beramono}
\usepackage{csquotes}
\usepackage[UKenglish,german]{babel}

\usepackage{fancyvrb}

\widowpenalty10000  % http://tex.stackexchange.com/questions/4152/how-do-i-prevent-widow-orphan-lines
\clubpenalty10000

\title{The SysSon Platform}
\subtitle{Technical Report TR-2017-01-1\\Institute of Electronic Music and Acoustics, Graz\\(Status: in progress)}
\author{Hanns Holger Rutz}
% \date{09-Feb-2016}
\date{January 2017}

% cf. https://tex.stackexchange.com/questions/94126/change-font-to-only-section-and-subsection-of-my-document
%\usepackage{titlesec}
%\titleformat{\chapter}[display]
%  {\fontfamily{pag}\selectfont\huge\bfseries}
%  {\chaptertitlename\ \thechapter}
%  {20pt}
%  {\Huge}
%\titleformat{\section}
%  {\fontfamily{pag}\selectfont\bfseries\Large}
%  {\thesection}
%  {1em}
%  {}
%\titleformat{\subsection}
%  {\fontfamily{pag}\selectfont\bfseries\Large}
%  {\thesection}
%  {1em}
%  {}

\usepackage[backend=biber,authordate]{biblatex-chicago} % citereset=chapter
%\usepackage[backend=biber,natbib,isbn=false,useprefix=true,sorting=ydnt]{biblatex-chicago} % citereset=chapter
\addbibresource{all.bib} % add a bib-reference file
\addbibresource{rutz.bib} % add a bib-reference file

% warning: https://tex.stackexchange.com/questions/313477/
% \usepackage{csquotes}

\usepackage{tabularx}
% cf. https://tex.stackexchange.com/questions/84400/table-layout-with-tabularx-column-widths-502525
\newcolumntype{s}{>{\hsize=1cm}X}

% says you should load after babel and fontspec
\usepackage[shrink=10, babel=true]{microtype}	% http://tex.stackexchange.com/questions/141852/latex-allows-line-break-between-concluding-em-dash-and-comma-before-a-new-sub-cl/141854#141854

% has to come first for full scale TeX voodoo bullcrap
\usepackage{hyperref}
% get rid of the horrible coloured boxes around links
\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}
% has to come after frickin hyperref
\VerbatimFootnotes

\newcommand{\todo}[1]{\colorbox{yellow}{\textsc{todo}: #1}}

\newcommand{\quot}[1]{\guillemotleft {#1}\guillemotright}

\newcommand{\worktitle}[1]{\textit{#1}}

\newcommand{\workentry}[2]{\vspace{7.5pt}\noindent\textbf{#1} (#2)}
\newcommand{\workentrySel}[2]{\vspace{7.5pt}\noindent\textbf{#1}$*$ (#2)}

\newcommand{\figref}[1]{Fig.~\ref{#1}}

\newcommand{\software}[1]{\textit{#1}}

\newcommand{\sysson}[0]{SysSon}
\newcommand{\syssonVersion}[0]{1.8.0}
\newcommand{\syssonVersionS}[0]{1.8.0-SNAPSHOT}

\newcommand{\artefacts}[0]{\textsc{Artefacts:}}
\newcommand{\assessment}[0]{\textsc{Assessment:}}

\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinestyle{plain}{
  frame=tb,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=true,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=none,
  keepspaces=true,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

\lstdefinestyle{scala}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=true,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=none,
  keepspaces=true,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

\lstdefinestyle{scala-small}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=true,
  columns=flexible,
  basicstyle={\tiny\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=none,
  keepspaces=true,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}

\begin{document}
% \begin{titlepage}
\maketitle
\selectlanguage{UKenglish}
\thispagestyle{empty}
\newpage
\section{Adding an Offline Preprocessing Stage}

The current workflow has been to experiment with matrix preprocessing directly in the IntelliJ IDE and outside of Mellite/SysSon. This is fine, because the IDE is much more powerful, and we have easier access to some of the utilities. However, the problem arises that we will need to make the results of these experiments available inside SysSon if we want to eventually allow the users to apply particular, newly developed preprocessing steps. We have done so with a separate menu-item to calculate anomalies, for example. We would now need to add another item for analysing the blobs. Obviously, this is not a scalable approach.

In the summer of 2016, I began to implement the next-generation FScape software, a toolkit for musical signal processing, using a UGen graph approach similar to ScalaCollider, but running offline. The back-end architecture uses the Akka-Stream framework, while the front-end API is very similar to ScalaCollider. This new FScape 2.x is already stable enough to use, as was demonstrated in various audio- and video-installations last year. Furthermore, it has a basic integration with SoundProcesses now. It is therefore an obvious choice to extend FScape with SysSon-specific UGens. A possible drawback is that the streams are weakly typed one dimensional signals (although channels can be bundled). There are a number of two-dimensional matrix and image processing UGens, but it requires that row size or width information must be explicitly passed into the respective UGens. Nevertheless, we estimate that it will be possible to implement the required UGens for SysSon matrices this way.

\subsection{Implementation Steps}

We have collected the required steps for a full implementation for processing matrices offline in SysSon below. As of February 2, the first five steps have been completed.

\begin{enumerate}
\item enhance SoundProcesses by "lazily" calculated objects
\item implement such a lazy object interface for FScape output
\item implement a caching mechanism for these objects
\item make it possible to use these cached instances as input to the real-time playback
\item implement a simple SysSon matrix reader in FScape
%
\item make \verb!Sonification! instance matrices available in FScape
\item add commonly required meta data UGens, such as rank, size, dimensional information
\item add dimensional operators, such as transposition
\item add the possibility to \emph{output} matrices from FScape
\item make it possible to use these cached matrices as input to the real-time sonification
\item add UGens necessary to complete existing processes (anomalies, blobs)
\end{enumerate}

\subsubsection{Lazily Calculated Objects}

\software{SoundProcesses} now makes a simple provision to add support for lazily calculated objects (as would occur in \software{FScape}). A new \Verb!Obj! type \Verb!Gen! was added that acts as an opaque container for an eventually calculated peer object.

The only way to get hold of that value is to create a \Verb!GenView! instance. This instance, once created and until it is disposed, acts as an acquired lock on the caching/cached resource. A \Verb!GenView! is created by passing a \Verb!Gen! instance and an implicit \Verb!GenContext!. This context ensures that rendering processes are shared within a workspace between multiple occurrences of the \Verb!Gen! objects.

The \Verb!GenView! is similar to a transactional future. It has a method \Verb!value! that returns a \Verb!Option[Try[Obj[S]]!---corresponding to a \Verb!future.value!---a state that indicates the current progress or completion, and it is observable for state updates.

\subsubsection{Lazily Objects in FScape}

Similar to aural views, gen views are created by factories which are globally registered for a specific peer data type. In \Verb!FScape! we created a new object type \Verb!FScape.Output! that is a sub-type of \Verb!Gen!, and a default gen-view factory for this type. The view type is \Verb!OutputGenView! and it combines an instance of \Verb!FScape.Rendering! with an \Verb!FScape.Output!. We ensure that at maximum one rendering instance is running for an \Verb!FScape! object. All outputs, i.e. all lazily created by rendering the same graph function, are thus grouped together.

\subsubsection{Caching Objects}

When requesting an instance of \Verb!FScape.Rendering!, the graph function is converted into a cache key. The graph expansion is now explicitly divided into two stages, the first giving the collection of UGens, the second creating the stream nodes in the Akka framework. In order to calculate the cache key, we only have to execute the first stage. The structure captures the positions of the constants and UGens in the graph, and collects for each UGen an ``auxiliary'' object that represents the structural data uniquely identifying the environmental inputs of the UGen. For example, this may contain the path name, length and modification date of an input file, or a constant such as an integer or a string obtained during the first graph expansion stage.

Each entry in the cache is associated with a value structure that contains the peer data for all \Verb!FScape.Output! instances. When graph elements provide a coupling to an \Verb!FScape.Output!, they call \Verb!requestOutput! on the graph builder, providing the a \Verb!Output.Reader! that can \emph{de-serialize} the peer data stored in a cache value. Correspondingly, \Verb!requestOutput! returns an \Verb!OutputRef!, eventually passed to the stream graph element, that has a method \Verb!complete! to be invoked once that stream graph element has determined the peer data. The value passed to \Verb!complete! is an instance of \Verb!Output.Writer!, capable of adding serialised data to the cache value when it is written.

So, when requesting an instance of \Verb!FScape.Rendering!, either a valid cache entry is found (through the structure key), and the ``rendering'' is actually not a running rendering but an encapsulation of the already known result, or if not, an actual rendering will begin, and when it terminates, the cache entry is written.

To summarise, \Verb!FScape.Rendering! denotes an ongoing or finished (read from cache) rendering process, it encapsulates the peer data of \emph{all} connected outputs of an \Verb!FScape! object. The outputs are opaque objects, by way of \Verb!GenView(output)! one obtains \Verb!OutputGenView! instances for these, which in turn extract their particular peer data by querying the common \Verb!Rendering! instance. By calling \Verb!genView.dispose()!, access to that data is nominally lost, and the system may decide to wipe the cache data if needed (for example, if a given maximum cache size is exceeded).

\subsubsection{Using Cached Objects in Real-Time Playback}

Cached objects appear as values in another object's attribute map, so for example, the result of calculating a number might be a \Verb!Gen! whose peer data is an integer or a double, and this \Verb!Gen! instance will now appear in an attribute map instead of an ``eager'' \Verb!IntObj! or \Verb!DoubleObj!. This requires that especially the implementation of \Verb!AuralProc! recognises these new objects.

While a \Verb!UGenGraphBuilder.Value! has a \verb!async! flag that could be useful here, we can first focus on input that must be resolved at graph expansion time, including scalar attributes without default value (and thus without a default number of channels). This is a simpler approach: When encountering a \Verb!Gen! during a \Verb!requestInput! call, we get hold of a \Verb!GenView!. We maintain a new map inside the aural-proc from attribute keys to gen-view instances. So, in \verb!requestInput!, when this map does not contain the attribute key, we create the \Verb!GenView! and store it there. We then call \Verb!value! to see if the peer value is already available. If so, we look at this value and proceed as normal. If not, it means we need to wait for the rendering, and at this time, we cannot determine required properties such as the number-of-channels of a scalar input. We can throw a \Verb!MissingIn! exception, an established mechanism for deferring the playback of a proc until all required attribute inputs are present. Additionally, we need to track the completion of any \Verb!GenView! we have thus created. Similar to the \verb!attrAdded! method which is invoked when an attribute is added to the proc's attribute map, we check if the completed view corresponds to one of the missing keys in the incomplete UGen builder state. If so, we attempt the build again.

A bit of complexity is added by the fact that we now must support \Verb!Gen! in a number of scenarios, from scalar values to in-memory buffers to streamed buffers. We have implemented all of these cases, but a future overhaul should look at a more general and DRY solution.

\subsubsection{Simple SysSon Matrix Reader UGen}

\todo{}

\subsubsection{Next Steps}

The remaining six steps will be covered in the next technical report.

%\subsubsection{Accessing Sonification Instances}
%
%\subsubsection{Meta Data UGens}
%
%\subsubsection{Dimensional Operators}
%
%\subsubsection{Matrix Output}
%
%\subsubsection{Matrix Linkage from Offline to Real-Time}
%
%\subsubsection{Implementing Anomalies and Blobs}

%%
%\begin{lstlisting}[style=scala]
%trait Output[S <: Sys[S]] {
%  def fscape: FScape[S]
%  def key   : String
%  def tpe   : Obj.Type
%  // def tpeID: Int
%  def value(implicit tx: S#Tx): Option[Obj[S]]  
%}
%\end{lstlisting}
%%

\end{document}